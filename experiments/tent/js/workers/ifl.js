// Generated by CoffeeScript 1.3.3
(function() {
  var AMF, ByteArray, IFLAnimation, IFLAnimationSamplerMatrix3D, IFLAnimationTrack, IFLBitmap, IFLCamera, IFLColor, IFLFolder, IFLID, IFLIndexBuffer, IFLJoint, IFLJointBind, IFLLibrary, IFLLight, IFLMaterial, IFLMesh, IFLMeshContainer, IFLNode, IFLParser, IFLSubMesh, IFLVertexBuffer, IFLVertexBufferDecomposed, console, namespace,
    _this = this,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (!this.hasOwnProperty("console")) {
    console = {};
    console.log = function(msg) {
      return postMessage({
        type: "console",
        action: "log",
        msg: msg
      });
    };
    console.warn = function(msg) {
      return postMessage({
        type: "console",
        action: "warn",
        msg: msg
      });
    };
    console.error = function(msg) {
      return postMessage({
        type: "console",
        action: "error",
        msg: msg
      });
    };
    console.info = function(msg) {
      return postMessage({
        type: "console",
        action: "info",
        msg: msg
      });
    };
  }

  namespace = function(name, values) {
    var key, subpackage, target, value, _i, _len, _ref;
    if (this.hasOwnProperty("window")) {
      target = window;
    } else if (this.hasOwnProperty("exports")) {
      target = exports;
    } else {
      target = this;
    }
    if (name.length > 0) {
      _ref = name.split('.');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subpackage = _ref[_i];
        target = target[subpackage] || (target[subpackage] = {});
      }
    }
    for (key in values) {
      value = values[key];
      target[key] = value;
    }
    return target;
  };

  namespace('', {
    namespace: namespace
  });

  namespace("amf", {
    AMF: AMF = (function() {

      function AMF() {}

      AMF.aliases = {};

      AMF.registerClassAlias = function(fullClassPath, classAlias) {
        return this.aliases[fullClassPath] = classAlias;
      };

      AMF.getClassForAlias = function(fullClassPath) {
        return this.aliases[fullClassPath];
      };

      return AMF;

    })()
  });

  namespace("amf", {
    Amf0Types: {
      kNumberType: 0,
      kBooleanType: 1,
      kStringType: 2,
      kObjectType: 3,
      kMovieClipType: 4,
      kNullType: 5,
      kUndefinedType: 6,
      kReferenceType: 7,
      kECMAArrayType: 8,
      kObjectEndType: 9,
      kStrictArrayType: 10,
      kDateType: 11,
      kLongStringType: 12,
      kUnsupportedType: 13,
      kRecordsetType: 14,
      kXMLObjectType: 15,
      kTypedObjectType: 16,
      kAvmPlusObjectType: 17
    }
  });

  namespace("amf", {
    Amf3Types: {
      kUndefinedType: 0,
      kNullType: 1,
      kFalseType: 2,
      kTrueType: 3,
      kIntegerType: 4,
      kDoubleType: 5,
      kStringType: 6,
      kXMLType: 7,
      kDateType: 8,
      kArrayType: 9,
      kObjectType: 10,
      kAvmPlusXmlType: 11,
      kByteArrayType: 12,
      kVectorIntType: 13,
      kVectorUintType: 14,
      kVectorNumberType: 15,
      kVectorObjectType: 16
    }
  });

  namespace("amf", {
    Endian: {
      BIG: 0,
      LITTLE: 1
    }
  });

  namespace("amf", {
    ObjectEncoding: {
      AMF0: 0,
      AMF3: 3
    }
  });

  namespace("amf", {
    ByteArray: ByteArray = (function() {

      ByteArray.prototype.data = [];

      ByteArray.prototype.length = 0;

      ByteArray.prototype.pos = 0;

      ByteArray.prototype.pow = Math.pow;

      ByteArray.prototype.endian = amf.Endian.BIG;

      ByteArray.prototype.TWOeN23 = Math.pow(2, -23);

      ByteArray.prototype.TWOeN52 = Math.pow(2, -52);

      ByteArray.prototype.ObjectEncoding = amf.ObjectEncoding.AMF3;

      ByteArray.prototype.stringTable = [];

      ByteArray.prototype.objectTable = [];

      ByteArray.prototype.traitTable = [];

      ByteArray.prototype.progressCallback = function(parsed, total) {};

      ByteArray.prototype.needTraitSnapshot = false;

      ByteArray.prototype.tempTi = null;

      ByteArray.prototype.float64Zero1 = "0";

      ByteArray.prototype.float64Zero2 = "00";

      ByteArray.prototype.float64Zero3 = "000";

      ByteArray.prototype.float64Zero4 = "0000";

      ByteArray.prototype.float64Zero5 = "00000";

      ByteArray.prototype.float64Zero6 = "000000";

      ByteArray.prototype.float64Zero7 = "0000000";

      ByteArray.prototype.float64Zero8 = "00000000";

      ByteArray.prototype.float64Zero9 = "000000000";

      ByteArray.prototype.float64Zero10 = "0000000000";

      ByteArray.prototype.float64Zero11 = "00000000000";

      ByteArray.prototype.float64Zero12 = "000000000000";

      ByteArray.prototype.float64Zero13 = "0000000000000";

      ByteArray.prototype.float64Zero14 = "00000000000000";

      ByteArray.prototype.float64Zero15 = "000000000000000";

      ByteArray.prototype.float64Zero16 = "0000000000000000";

      ByteArray.prototype.float64Zero17 = "00000000000000000";

      ByteArray.prototype.float64Zero18 = "000000000000000000";

      ByteArray.prototype.float64Zero19 = "0000000000000000000";

      ByteArray.prototype.float64Zero20 = "00000000000000000000";

      ByteArray.prototype.float64Zero21 = "000000000000000000000";

      ByteArray.prototype.float64Zero22 = "0000000000000000000000";

      ByteArray.prototype.float64Zero23 = "00000000000000000000000";

      ByteArray.prototype.float64CacheS12 = {};

      ByteArray.prototype.float64CacheS3 = {};

      ByteArray.prototype.float64CacheParseInt = {};

      ByteArray.prototype.dispose = function() {
        this.float64CacheParseInt = this.float64CacheS12 = this.float64CacheS3 = this.data = this.traitTable = this.stringTable = this.objectTable = null;
      };

      function ByteArray(data, endian) {
        var func, funcExt, funcMap, funcs, _i, _len;
        this.data = data != null ? data : [];
        this.endian = endian != null ? endian : amf.Endian.BIG;
        this.length = data.length;
        funcExt = endian === amf.Endian.BIG ? 'BE' : 'LE';
        funcs = ['readInt32', 'readInt16', 'readUInt30', 'readUInt32', 'readUInt16', 'readFloat32', 'readFloat64'];
        for (_i = 0, _len = funcs.length; _i < _len; _i++) {
          func = funcs[_i];
          ByteArray.prototype[func] = ByteArray.prototype[func + funcExt];
        }
        funcMap = {
          readUnsignedByte: 'readByte',
          readUnsignedInt: 'readUInt32',
          readFloat: 'readFloat32',
          readDouble: 'readFloat64',
          readShort: 'readInt16',
          readUnsignedShort: 'readUInt16',
          readBoolean: 'readBool',
          readInt: 'readInt32'
        };
        for (func in funcMap) {
          this[func] = ByteArray.prototype[funcMap[func]];
        }
      }

      ByteArray.prototype.readByte = function() {
        if (this.pos % 10000 === 0) {
          this.progressCallback(this.pos, this.length);
        }
        return this.data[this.pos++];
      };

      ByteArray.prototype.writeByte = function(byte) {
        return this.data.push(byte);
      };

      ByteArray.prototype.readBool = function() {
        if (this.data[this.pos++] & 0xFF) {
          return true;
        } else {
          return false;
        }
      };

      ByteArray.prototype.readUInt29 = function() {
        var b, value;
        b = this.readByte() & 0xFF;
        if (b < 128) {
          return b;
        }
        value = (b & 0x7F) << 7;
        b = this.readByte() & 0xFF;
        if (b < 128) {
          return value | b;
        }
        value = (value | (b & 0x7F)) << 7;
        b = this.readByte() & 0xFF;
        if (b < 128) {
          return value | b;
        }
        value = (value | (b & 0x7F)) << 8;
        b = this.readByte() & 0xFF;
        return value | b;
      };

      ByteArray.prototype.readUInt16BE = function() {
        var data, pos;
        data = this.data;
        pos = (this.pos += 2) - 2;
        return ((data[pos] & 0xFF) << 8) | (data[++pos] & 0xFF);
      };

      ByteArray.prototype.readUInt30BE = function() {
        var ch1, ch2, ch3, ch4;
        ch1 = this.readByte();
        ch2 = this.readByte();
        ch3 = this.readByte();
        ch4 = this.readByte();
        if (ch1 >= 64) {
          void 0;
        }
        return ch4 | (ch3 << 8) | (ch2 << 16) | (ch1 << 24);
      };

      ByteArray.prototype.readUInt32BE = function() {
        var data, pos;
        data = this.data;
        pos = (this.pos += 4) - 4;
        return ((data[pos] & 0xFF) << 24) | ((data[++pos] & 0xFF) << 16) | ((data[++pos] & 0xFF) << 8) | (data[++pos] & 0xFF);
      };

      ByteArray.prototype.readInt16BE = function() {
        var data, pos, x;
        data = this.data;
        pos = (this.pos += 2) - 2;
        x = ((data[pos] & 0xFF) << 8) | (data[++pos] & 0xFF);
        if (x >= 32768) {
          x - 65536;
        }
        return x;
      };

      ByteArray.prototype.readInt32BE = function() {
        var data, pos, x;
        data = this.data;
        pos = (this.pos += 4) - 4;
        x = ((data[pos] & 0xFF) << 24) | ((data[++pos] & 0xFF) << 16) | ((data[++pos] & 0xFF) << 8) | (data[++pos] & 0xFF);
        if (x >= 2147483648) {
          return x - 4294967296;
        }
        return x;
      };

      ByteArray.prototype.readFloat32BE = function() {
        var b1, b2, b3, b4, data, exp, pos, sig, sign;
        data = this.data;
        pos = (this.pos += 4) - 4;
        b1 = data[pos] & 0xFF;
        b2 = data[++pos] & 0xFF;
        b3 = data[++pos] & 0xFF;
        b4 = data[++pos] & 0xFF;
        sign = 1 - ((b1 >> 7) << 1);
        exp = (((b1 << 1) & 0xFF) | (b2 >> 7)) - 127;
        sig = ((b2 & 0x7F) << 16) | (b3 << 8) | b4;
        if (sig === 0 && exp === -127) {
          return 0;
        }
        return sign * (1 + this.TWOeN23 * sig) * this.pow(2, exp);
      };

      ByteArray.prototype.readFloat64BE = function() {
        var b1, b2, b3, b4, b5, b6, b7, b8, exp, l, s1, s2, s3, sig, sign;
        b1 = this.readByte();
        b2 = this.readByte();
        b3 = this.readByte();
        b4 = this.readByte();
        b5 = this.readByte();
        b6 = this.readByte();
        b7 = this.readByte();
        b8 = this.readByte();
        sign = 1 - ((b1 >> 7) << 1);
        exp = (((b1 << 4) & 0x7FF) | (b2 >> 4)) - 1023;
        s1 = ((b2 & 0xF) << 16) | (b3 << 8) | b4;
        s2 = ((b5 & 0xF) << 16) | (b6 << 8) | b7;
        s3 = b8;
        if (!(this.float64CacheS12[s1] != null)) {
          this.float64CacheS12[s1] = s1.toString(2);
          l = this.float64CacheS12[s1].length;
          if (l < 24) {
            this.float64CacheS12[s1] = this["float64Zero" + String(24 - l)] + this.float64CacheS12[s1];
          }
        }
        if (!(this.float64CacheS12[s2] != null)) {
          this.float64CacheS12[s2] = s2.toString(2);
          l = this.float64CacheS12[s2].length;
          if (l < 24) {
            this.float64CacheS12[s2] = this["float64Zero" + String(24 - l)] + this.float64CacheS12[s2];
          }
        }
        if (!(this.float64CacheS3[s3] != null)) {
          this.float64CacheS3[s3] = s3.toString(2);
          l = this.float64CacheS3[s3].length;
          if (l < 8) {
            this.float64CacheS3[s3] = this["float64Zero" + String(8 - l)] + this.float64CacheS3[s3];
          }
        }
        s1 = this.float64CacheS12[s1];
        s2 = this.float64CacheS12[s2];
        s3 = this.float64CacheS3[s3];
        sig = parseInt(s1 + s2 + s3, 2);
        if (sig === 0 && exp === -1023) {
          return 0;
        }
        return sign * (1.0 + this.TWOeN52 * sig) * this.pow(2, exp);
      };

      ByteArray.prototype.readDate = function() {
        var time_ms, tz_min;
        time_ms = this.readDouble();
        tz_min = this.readUInt16();
        return new Date(time_ms + tz_min * 60 * 1000);
      };

      ByteArray.prototype.readString = function(len) {
        var str;
        str = "";
        while (len > 0) {
          str += String.fromCharCode(this.readUnsignedByte());
          len--;
        }
        return str;
      };

      ByteArray.prototype.readUTF = function() {
        return this.readString(this.readUnsignedShort());
      };

      ByteArray.prototype.readLongUTF = function() {
        return this.readString(this.readUInt30());
      };

      ByteArray.prototype.stringToXML = function(str) {
        var parser, xmlDoc;
        if (this.hasOwnProperty("window") && window.DOMParser) {
          parser = new DOMParser();
          xmlDoc = parser.parseFromString(str, "text/xml");
        } else {
          xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
          xmlDoc.async = false;
          xmlDoc.loadXML(str);
        }
        return xmlDoc;
      };

      ByteArray.prototype.readXML = function() {
        return this.stringToXML(this.readLongUTF());
      };

      ByteArray.prototype.readStringAMF3 = function() {
        var len, ref, str;
        ref = this.readUInt29();
        if ((ref & 0x1) === 0) {
          return this.stringTable[ref >> 1];
        }
        len = ref >> 1;
        if (len === 0) {
          return "";
        }
        str = this.readString(len);
        this.stringTable.push(str);
        return str;
      };

      ByteArray.prototype.readTraits = function(ref, store) {
        var i, propName, traitInfo, _i, _ref;
        if (store == null) {
          store = true;
        }
        if ((ref & 0x3) === 1 && ref !== 1) {
          return this.traitTable[ref >> 2];
        }
        traitInfo = {};
        traitInfo.properties = [];
        traitInfo.externalizable = (ref & 0x4) === 4;
        traitInfo.dynamic = (ref & 0x8) === 8;
        traitInfo.count = ref >> 4;
        if (store) {
          this.traitTable.push(traitInfo);
        }
        traitInfo.className = this.readStringAMF3();
        for (i = _i = 0, _ref = traitInfo.count; _i < _ref; i = _i += 1) {
          propName = this.readStringAMF3();
          traitInfo.properties.push(propName);
        }
        return traitInfo;
      };

      ByteArray.prototype.readExternalizable = function(className, o) {
        if ((o.readExternal != null)) {
          o.readExternal(this);
        } else {
          ifl.IFLParser.readExternal(o, this);
        }
        return null;
      };

      ByteArray.prototype.readObject = function() {
        var marker;
        marker = this.readByte();
        switch (marker) {
          case amf.Amf3Types.kUndefinedType:
            return void 0;
          case amf.Amf3Types.kNullType:
            return null;
          case amf.Amf3Types.kFalseType:
            return false;
          case amf.Amf3Types.kTrueType:
            return true;
          case amf.Amf3Types.kIntegerType:
            return this.readUInt29();
          case amf.Amf3Types.kDoubleType:
            return this.readDouble();
          case amf.Amf3Types.kStringType:
            return this.readStringAMF3();
          case amf.Amf3Types.kXMLType:
            return this.readXML();
          case amf.Amf3Types.kDateType:
            return this.readDateAMF3();
          case amf.Amf3Types.kArrayType:
            return this.readArrayAMF3();
          case amf.Amf3Types.kObjectType:
            return this.readObjectAMF3();
          case amf.Amf3Types.kAvmPlusXmlType:
            return this.readAVMPlusXMLAMF3();
          case amf.Amf3Types.kByteArrayType:
            return this.readByteArrayAMF3();
          case amf.Amf3Types.kVectorIntType:
            return this.readVectorIntAMF3();
          case amf.Amf3Types.kVectorUintType:
            return this.readVectorUintAMF3();
          case amf.Amf3Types.kVectorNumberType:
            return this.readVectorNumberAMF3();
          case amf.Amf3Types.kVectorObjectType:
            return this.readVectorObjectAMF3();
          default:
            console.warn("Object Marker at " + (this.pos - 1) + " not recognised, trying next byte");
            return this.readObject();
        }
      };

      ByteArray.prototype.readObjectAMF3 = function() {
        var al, className, externalizable, o, ref, ti;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        ti = this.readTraits(ref);
        className = ti.className;
        externalizable = ti.externalizable;
        al = AMF.getClassForAlias(className);
        if ((al != null)) {
          o = new al();
        } else {
          o = {};
        }
        this.objectTable.push(o);
        this.readExternalizable(className, o);
        return o;
      };

      ByteArray.prototype.readVectorIntAMF3 = function() {
        var array, index, len, obj, ref, ref2, _i, _len;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        len = ref >> 1;
        ref2 = this.readUInt29();
        array = new Int32Array(len);
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          obj = array[index];
          array[index] = this.readInt();
        }
        this.objectTable.push(array);
        return array;
      };

      ByteArray.prototype.readVectorUintAMF3 = function() {
        var array, index, len, obj, ref, ref2, _i, _len;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        len = ref >> 1;
        ref2 = this.readUInt29();
        array = new Uint32Array(len);
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          obj = array[index];
          array[index] = this.readUInt32();
        }
        this.objectTable.push(array);
        return array;
      };

      ByteArray.prototype.readVectorNumberAMF3 = function() {
        var array, index, len, obj, ref, ref2, _i, _len;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        len = ref >> 1;
        ref2 = this.readUInt29();
        array = new Float32Array(len);
        for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
          obj = array[index];
          array[index] = this.readDouble();
        }
        this.objectTable.push(array);
        return array;
      };

      ByteArray.prototype.readVectorObjectAMF3 = function() {
        var array, i, len, ref, ref2, ti2, _i;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        len = ref >> 1;
        array = [];
        this.objectTable.push(array);
        ref2 = this.readUInt29();
        ti2 = this.readTraits(ref2, false);
        for (i = _i = 0; _i < len; i = _i += 1) {
          array.push(this.readObject());
        }
        return array;
      };

      ByteArray.prototype.readByteArrayAMF3 = function() {
        var ba, i, len, ref, _i;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        len = ref >> 1;
        ba = new a3d.ByteArray();
        this.objectTable.push(ba);
        for (i = _i = 0; _i < len; i = _i += 1) {
          ba.writeByte(this.readByte());
        }
        return ba;
      };

      ByteArray.prototype.readAVMPlusXMLAMF3 = function() {
        var len, ref, str, xml;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.stringToXML(this.objectTable[ref >> 1]);
        }
        len = ref >> 1;
        if (len === 0) {
          return null;
        }
        str = this.readString(len);
        xml = this.stringToXML(str);
        this.objectTable.push(xml);
        return xml;
      };

      ByteArray.prototype.readDateAMF3 = function() {
        var d, ref, value;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        d = this.readDouble();
        value = new Date(d);
        this.objectTable.push(value);
        return value;
      };

      ByteArray.prototype.readArrayAMF3 = function() {
        var a, i, key, len, ref, result, _i;
        ref = this.readUInt29();
        if ((ref & 1) === 0) {
          return this.objectTable[ref >> 1];
        }
        len = ref >> 1;
        key = this.readStringAMF3();
        if (key === "") {
          a = (function() {
            var _i, _results;
            _results = [];
            for (i = _i = 0; _i < len; i = _i += 1) {
              _results.push(this.readObject());
            }
            return _results;
          }).call(this);
          this.objectTable.push(a);
          return a;
        }
        result = {};
        this.objectTable.push(result);
        while (key !== "") {
          result[key] = this.readObject();
          key = this.readStringAMF3();
        }
        for (i = _i = 0; _i < len; i = _i += 1) {
          result[i] = this.readObject();
        }
        return result;
      };

      return ByteArray;

    })()
  });

  namespace("ifl", {
    IFLParser: IFLParser = (function() {

      function IFLParser() {}

      IFLParser._loadedObjectTable = null;

      IFLParser._library = null;

      IFLParser._knownClasses = {};

      IFLParser._knownInterfaces = {};

      IFLParser.METHOD_OBJECT = "a";

      IFLParser.METHOD_UTF = "b";

      IFLParser.METHOD_BOOLEAN = "c";

      IFLParser.METHOD_BYTE = "d";

      IFLParser.METHOD_DOUBLE = "e";

      IFLParser.METHOD_FLOAT = "f";

      IFLParser.METHOD_INT = "g";

      IFLParser.METHOD_SHORT = "h";

      IFLParser.METHOD_UINT = "i";

      IFLParser._customMethodReadHandlers = {
        a: "readObject",
        b: "readUTF"
      };

      IFLParser._methodReadHandlers = {
        c: "readBoolean",
        d: "readByte",
        e: "readDouble",
        f: "readFloat",
        g: "readInt",
        h: "readShort",
        i: "readUnsignedInt"
      };

      IFLParser.setKnownInterface = function(fullClassPath, classType) {
        return IFLParser._knownInterfaces[fullClassPath] = classType;
      };

      IFLParser.setKnownClass = function(fullClassPath, classType) {
        AMF.registerClassAlias(fullClassPath, classType);
        return IFLParser._knownClasses[fullClassPath] = classType;
      };

      IFLParser.readFile = function(object, input) {
        this._loadedObjectTable = input.readObject();
        return this.readExternal(object, input);
      };

      IFLParser.readExternal = function(object, input) {
        var desc, i, l, method, objectType, prop, _i;
        objectType = input.readUTF();
        object.iflType = objectType.split("::")[1];
        desc = this._loadedObjectTable[objectType];
        l = desc.length;
        for (i = _i = 0; _i < l; i = _i += 2) {
          prop = desc[i];
          method = desc[i + 1];
          if (!(method != null)) {
            throw "Parse Error";
          }
          this.readMethod(method, object, prop, input);
        }
        return null;
      };

      IFLParser.readMethod = function(method, object, prop, input) {
        var customHandler, nativeHandler;
        nativeHandler = this._methodReadHandlers[method];
        if ((nativeHandler != null)) {
          object[prop] = input[nativeHandler]();
        } else {
          customHandler = this._customMethodReadHandlers[method];
          if ((customHandler != null)) {
            this[customHandler](object, prop, input);
          } else {
            throw "Cannot find a method to read property " + prop + " on object " + object + " (method: " + method + ")";
          }
        }
        return null;
      };

      IFLParser.isKnownClassString = function(str) {
        return this._knownClasses[str] != null;
      };

      IFLParser.isKnownInterfaceString = function(str) {
        return this._knownInterfaces[str] != null;
      };

      IFLParser.isSupportedBuiltinClassString = function(str) {
        return str === "flash.utils::Dictionary" || str === "flash.geom::Matrix" || str === "flash.geom::Matrix3D" || str === "flash.geom::Vector3D" || str === "flash.utils::ByteArray" || str === "Array" || this.isVectorString(str);
      };

      IFLParser.isBuiltinClassString = function(str) {
        return str === "int" || str === "uint" || str === "Number" || str === "String";
      };

      IFLParser.isVectorString = function(str) {
        return str.indexOf("__AS3__.vec::Vector") !== -1;
      };

      IFLParser.readUTF = function(object, prop, input) {
        if (input.readBoolean()) {
          return object[prop] = input.readUTF();
        }
      };

      IFLParser.readObject = function(object, prop, input) {
        var type;
        if (input.readBoolean()) {
          type = input.readUTF();
          if (type === "" || !type) {
            throw "Parse Error";
          }
          if (this.isKnownClassString(type)) {
            object[prop] = input.readObject();
          } else if (type === "flash.geom::Matrix3D") {
            this.readMatrix3D(object, prop, input);
          } else if (type === "flash.utils::ByteArray") {
            this.readByteArray(object, prop, input);
          } else if (type === "flash.geom::Matrix") {
            this.readMatrix(object, prop, input);
          } else if (type === "Array") {
            this.readArray(object, prop, input);
          } else if (type === "flash.geom::Vector3D") {
            this.readVector3D(object, prop, input);
          } else if (type === "flash.utils::Dictionary") {
            this.readDictionary(object, prop, input);
          } else if (this.isVectorString(type)) {
            this.readVector(object, prop, input);
          } else {
            AMF.registerClassAlias(type, {}.constructor);
            input.readObject();
          }
        }
        return null;
      };

      IFLParser.forceRead = function(object, prop, type, input) {
        var returnObj;
        returnObj = {};
        if (this.isKnownClassString(type)) {
          return input.readObject();
        } else if (this.isSupportedBuiltinClassString(type)) {
          if (type === "flash.geom::Matrix") {
            this.readMatrix(returnObj, "prop", input);
          } else if (type === "flash.geom::Matrix3D") {
            this.readMatrix3D(returnObj, "prop", input);
          } else if (type === "flash.utils::ByteArray") {
            this.readByteArray(returnObj, "prop", input);
          } else if (type === "flash.utils::Dictionary") {
            this.readDictionary(returnObj, "prop", input);
          } else if (type === "flash.geom::Vector3D") {
            this.readVector3D(returnObj, "prop", input);
          } else if (this.isVectorString(type)) {
            this.readVector(returnObj, "prop", input);
          }
        } else if (this.isBuiltinClassString(type)) {
          if (type === "int") {
            returnObj.prop = input.readInt();
          } else if (type === "uint") {
            returnObj.prop = input.readUnsignedInt();
          } else if (type === "Number") {
            returnObj.prop = input.readFloat();
          } else if (type === "String") {
            returnObj.prop = input.readUTF();
          }
        } else {
          console.warn("Reading", prop, "on", object, "is unknown type:", type);
          if (this.isKnownClassString(type)) {
            input.readObject();
          } else if (type === "flash.geom::Matrix3D") {
            this.readMatrix3D({}, prop, input);
          } else if (type === "flash.geom::Matrix") {
            this.readMatrix({}, prop, input);
          } else if (type === "flash.utils::ByteArray") {
            this.readByteArray({}, prop, input);
          } else if (type === "Array") {
            this.readArray({}, prop, input);
          } else if (type === "flash.geom::Vector3D") {
            this.readVector3D({}, prop, input);
          } else if (type === "flash.utils::Dictionary") {
            this.readDictionary({}, prop, input);
          } else if (this.isVectorString(type)) {
            this.readVector({}, prop, input);
          } else {
            AMF.registerClassAlias(type, {}.constructor);
            input.readObject();
          }
        }
        return returnObj.prop;
      };

      IFLParser.readMatrix3D = function(object, prop, input) {
        var dat;
        dat = [];
        dat[0] = input.readFloat();
        dat[1] = input.readFloat();
        dat[2] = input.readFloat();
        dat[3] = input.readFloat();
        dat[4] = input.readFloat();
        dat[5] = input.readFloat();
        dat[6] = input.readFloat();
        dat[7] = input.readFloat();
        dat[8] = input.readFloat();
        dat[9] = input.readFloat();
        dat[10] = input.readFloat();
        dat[11] = input.readFloat();
        dat[12] = input.readFloat();
        dat[13] = input.readFloat();
        dat[14] = input.readFloat();
        dat[15] = input.readFloat();
        return object[prop] = dat;
      };

      IFLParser.readByteArray = function(object, prop, input) {
        var ba, l;
        l = input.readInt();
        ba = new Uint8Array(l);
        ba.set(input.data.subarray(input.pos, input.pos + l));
        input.pos += l;
        object[prop] = ba;
        return null;
      };

      IFLParser.readMatrix = function(object, prop, input) {
        var m;
        m = {};
        m.a = input.readFloat();
        m.b = input.readFloat();
        m.c = input.readFloat();
        m.d = input.readFloat();
        m.tx = input.readFloat();
        m.ty = input.readFloat();
        object[prop] = m;
        return null;
      };

      IFLParser.readArray = function(object, prop, input) {
        var arr, i, l, objType, _i;
        objType = input.readUTF();
        if (this.isKnownClassString(objType) || this.isBuiltinClassString(objType)) {
          object[prop] = input.readObject();
        } else if (this.isSupportedBuiltinClassString(objType)) {
          arr = [];
          l = input.readInt();
          for (i = _i = 0; _i < l; i = _i += 1) {
            if (input.readBoolean()) {
              arr[i] = this.forceRead(arr, i, objType, input);
            }
          }
          object[prop] = arr;
        } else {
          AMF.registerClassAlias(objType, {}.constructor);
          input.readObject();
        }
        return null;
      };

      IFLParser.readVector3D = function(object, prop, input) {
        var v;
        v = {};
        v.x = input.readFloat();
        v.y = input.readFloat();
        v.z = input.readFloat();
        v.w = input.readFloat();
        object[prop] = v;
        return null;
      };

      IFLParser.readDictionary = function(object, prop, input) {
        var d, i, idsLength, key, keyClass, value, valueClass, _i;
        idsLength = input.readInt();
        keyClass = input.readUTF();
        valueClass = input.readUTF();
        d = {};
        for (i = _i = 0; _i < idsLength; i = _i += 1) {
          key = this.forceRead(object, prop, keyClass, input);
          value = this.forceRead(object, prop, valueClass, input);
          if ((key != null) && (value != null)) {
            d[key] = value;
          }
        }
        object[prop] = d;
        return null;
      };

      IFLParser.readVector = function(object, prop, input) {
        var i, obj, typeList, typeName, v, _i, _j, _ref, _ref1;
        typeName = input.readUTF();
        typeList = input.readObject();
        if (this.isKnownClassString(typeName) || this.isBuiltinClassString(typeName)) {
          return object[prop] = input.readObject();
        } else if (this.isKnownInterfaceString(typeName)) {
          v = [];
          for (i = _i = 0, _ref = typeList.length; _i < _ref; i = _i += 1) {
            if (this.isKnownClassString(typeList[i]) || this.isBuiltinClassString(typeList[i])) {
              obj = input.readObject();
              if ((obj != null)) {
                v.push(obj);
              } else {
                throw "Reading went wrong";
              }
            } else {
              console.warn("Reading Vector " + prop + " on " + object + ", Element: " + i + " is unknown type: " + typeList);
              AMF.registerClassAlias(typeList[i], {}.constructor);
              input.readObject();
            }
          }
          return object[prop] = v;
        } else if (this.isSupportedBuiltinClassString(typeName)) {
          v = [];
          for (i = _j = 0, _ref1 = typeList.length; _j < _ref1; i = _j += 1) {
            this.readObject(v, i.toString(), input);
          }
          return object[prop] = v;
        } else {
          console.warn("Reading " + prop + " on " + object + " is unknown type: " + typeName);
          AMF.registerClassAlias(typeName, {}.constructor);
          return input.readObject();
        }
      };

      return IFLParser;

    })()
  });

  namespace("ifl", {
    IFLID: IFLID = (function() {

      function IFLID() {}

      IFLID.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLID;

    })()
  });

  namespace("ifl", {
    IFLIndexBuffer: IFLIndexBuffer = (function() {

      function IFLIndexBuffer() {}

      IFLIndexBuffer.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLIndexBuffer;

    })()
  });

  namespace("ifl", {
    IFLAnimation: IFLAnimation = (function() {

      function IFLAnimation() {}

      IFLAnimation.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLAnimation;

    })()
  });

  namespace("ifl", {
    IFLAnimationSamplerMatrix3D: IFLAnimationSamplerMatrix3D = (function() {

      function IFLAnimationSamplerMatrix3D() {}

      IFLAnimationSamplerMatrix3D.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLAnimationSamplerMatrix3D;

    })()
  });

  namespace("ifl", {
    IFLAnimationTrack: IFLAnimationTrack = (function() {

      function IFLAnimationTrack() {}

      IFLAnimationTrack.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLAnimationTrack;

    })()
  });

  namespace("ifl", {
    IFLBitmap: IFLBitmap = (function() {

      function IFLBitmap() {}

      IFLBitmap.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLBitmap;

    })()
  });

  namespace("ifl", {
    IFLColor: IFLColor = (function() {

      function IFLColor() {}

      IFLColor.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLColor;

    })()
  });

  namespace("ifl", {
    IFLFolder: IFLFolder = (function() {

      function IFLFolder() {}

      IFLFolder.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLFolder;

    })()
  });

  namespace("ifl", {
    IFLNode: IFLNode = (function() {

      function IFLNode() {}

      IFLNode.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLNode;

    })()
  });

  namespace("ifl", {
    IFLCamera: IFLCamera = (function(_super) {

      __extends(IFLCamera, _super);

      function IFLCamera() {
        return IFLCamera.__super__.constructor.apply(this, arguments);
      }

      return IFLCamera;

    })(IFLNode)
  });

  namespace("ifl", {
    IFLSubMesh: IFLSubMesh = (function() {

      function IFLSubMesh() {}

      IFLSubMesh.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLSubMesh;

    })()
  });

  namespace("ifl", {
    IFLMesh: IFLMesh = (function(_super) {

      __extends(IFLMesh, _super);

      function IFLMesh() {
        return IFLMesh.__super__.constructor.apply(this, arguments);
      }

      return IFLMesh;

    })(IFLNode)
  });

  namespace("ifl", {
    IFLMeshContainer: IFLMeshContainer = (function(_super) {

      __extends(IFLMeshContainer, _super);

      function IFLMeshContainer() {
        return IFLMeshContainer.__super__.constructor.apply(this, arguments);
      }

      return IFLMeshContainer;

    })(IFLNode)
  });

  namespace("ifl", {
    IFLJoint: IFLJoint = (function(_super) {

      __extends(IFLJoint, _super);

      function IFLJoint() {
        return IFLJoint.__super__.constructor.apply(this, arguments);
      }

      return IFLJoint;

    })(IFLNode)
  });

  namespace("ifl", {
    IFLJointBind: IFLJointBind = (function() {

      function IFLJointBind() {}

      IFLJointBind.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLJointBind;

    })()
  });

  namespace("ifl", {
    IFLLight: IFLLight = (function(_super) {

      __extends(IFLLight, _super);

      function IFLLight() {
        return IFLLight.__super__.constructor.apply(this, arguments);
      }

      return IFLLight;

    })(IFLNode)
  });

  namespace("ifl", {
    IFLMaterial: IFLMaterial = (function() {

      function IFLMaterial() {}

      IFLMaterial.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLMaterial;

    })()
  });

  namespace("ifl", {
    IFLLibrary: IFLLibrary = (function() {

      function IFLLibrary() {}

      IFLLibrary.prototype._content = null;

      IFLLibrary.prototype._contentByID = {};

      IFLLibrary.prototype.readExternal = function(input) {
        return IFLParser.readFile(this, input);
      };

      return IFLLibrary;

    })()
  });

  namespace("ifl", {
    IFLVertexAttribute: {
      POSITION: 0,
      UV: 1,
      NORMALS: 2,
      TANGENTS: 3,
      BINORMALS: 4,
      TEX_TANGENTS: 5,
      TEX_BINORMALS: 6,
      COLOR: 7,
      JOINT_0: 8,
      JOINT_1: 9,
      JOINT_2: 10,
      JOINT_3: 11,
      JOINT_4: 12,
      JOINT_INDICES: 13,
      JOINT_WEIGHTS: 14,
      SECONDARY_UV: 15
    }
  });

  namespace("ifl", {
    IFLVertexBuffer: IFLVertexBuffer = (function() {

      function IFLVertexBuffer() {}

      IFLVertexBuffer.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLVertexBuffer;

    })()
  });

  namespace("ifl", {
    IFLVertexBufferDecomposed: IFLVertexBufferDecomposed = (function() {

      function IFLVertexBufferDecomposed() {}

      IFLVertexBufferDecomposed.prototype.readExternal = function(input) {
        return IFLParser.readExternal(this, input);
      };

      return IFLVertexBufferDecomposed;

    })()
  });

}).call(this);

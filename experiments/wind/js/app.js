// Generated by CoffeeScript 1.4.0
(function() {
  var App, IFLLoader, IFLPhongFresnelShader, NoiseShader,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  IFLPhongFresnelShader = (function() {

    function IFLPhongFresnelShader() {}

    IFLPhongFresnelShader.prototype.uniforms = THREE.UniformsUtils.merge([
      THREE.UniformsLib["common"], THREE.UniformsLib["bump"], THREE.UniformsLib["normalmap"], THREE.UniformsLib["fog"], THREE.UniformsLib["shadowmap"], {
        "ambient": {
          type: "c",
          value: new THREE.Color(0xffffff)
        },
        "emissive": {
          type: "c",
          value: new THREE.Color(0x000000)
        },
        "specular": {
          type: "c",
          value: new THREE.Color(0x111111)
        },
        "shininess": {
          type: "f",
          value: 30
        },
        "wrapRGB": {
          type: "v3",
          value: new THREE.Vector3(1, 1, 1)
        },
        "tAux": {
          type: "t",
          value: null
        },
        "mFresnelBias": {
          type: "f",
          value: 0
        },
        "mFresnelGain": {
          type: "f",
          value: 1
        },
        "mFresnelPower": {
          type: "f",
          value: 0.0
        },
        "windMin": {
          type: "v2",
          value: new THREE.Vector2()
        },
        "windSize": {
          type: "v2",
          value: new THREE.Vector2()
        },
        "windDirection": {
          type: "v3",
          value: new THREE.Vector3(1, 0, 0)
        },
        "tWindForce": {
          type: "t",
          value: null
        },
        "windScale": {
          type: "f",
          value: 1.0
        }
      }
    ]);

    IFLPhongFresnelShader.prototype.vertexShader = ["#define PHONG", "varying vec3 vViewPosition;", "varying vec3 vNormal;", "varying vec3 vNWorld;", "varying vec3 vI;", THREE.ShaderChunk["map_pars_vertex"], THREE.ShaderChunk["lightmap_pars_vertex"], "varying vec3 vReflect;", "uniform vec2 windMin;", "uniform vec2 windSize;", "uniform vec3 windDirection;", "uniform sampler2D tWindForce;", "uniform float windScale;", "uniform float refractionRatio;", "uniform bool useRefract;", "varying vec3 vWorldPosition;", "varying float vWindForce;", THREE.ShaderChunk["color_pars_vertex"], THREE.ShaderChunk["morphtarget_pars_vertex"], THREE.ShaderChunk["skinning_pars_vertex"], "void main() {", THREE.ShaderChunk["map_vertex"], THREE.ShaderChunk["lightmap_vertex"], THREE.ShaderChunk["color_vertex"], THREE.ShaderChunk["morphnormal_vertex"], THREE.ShaderChunk["skinbase_vertex"], THREE.ShaderChunk["skinnormal_vertex"], THREE.ShaderChunk["defaultnormal_vertex"], "vNormal = objectNormal;", THREE.ShaderChunk["morphtarget_vertex"], THREE.ShaderChunk["skinning_vertex"], "vec4 mvPosition;", "#ifdef USE_SKINNING", "mvPosition = modelViewMatrix * skinned;", "#endif", "#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )", "mvPosition = modelViewMatrix * vec4( morphed, 1.0 );", "#endif", "#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )", "vec4 wpos = modelMatrix * vec4( position, 1.0 );", "wpos.z = -wpos.z;", "vec2 totPos = wpos.xz - windMin;", "vec2 windUV = totPos / windSize;", "vWindForce = texture2D(tWindForce,windUV).x;", "float windVertexScale = color.x;", "float windMod = ((1.0 - vWindForce)*windVertexScale) * windScale;", "vec4 pos = vec4(position , 1.0);", "pos.x += windMod * windDirection.x;", "pos.y += windMod * windDirection.y;", "pos.z += windMod * windDirection.z;", "mvPosition = modelViewMatrix *  pos;", "#endif", "gl_Position = projectionMatrix * mvPosition;", "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk["worldpos_vertex"], "#if defined( USE_ENVMAP )", "vNWorld = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;", "vI = normalize( mPosition.xyz - cameraPosition );", "if ( useRefract ) {", "vReflect = refract( vI, normalize( vNWorld.xyz ), refractionRatio );", "} else {", "vReflect = reflect( vI, normalize( vNWorld.xyz ) );", "}", "#endif", "vWorldPosition = mPosition.xyz;", "}"].join("\n");

    IFLPhongFresnelShader.prototype.fragmentShader = ["uniform vec3 diffuse;", "uniform float opacity;", "uniform vec3 ambient;", "uniform vec3 emissive;", "uniform vec3 specular;", "uniform float shininess;", "uniform sampler2D tAux;", "uniform float mFresnelBias;", "uniform float mFresnelGain;", "uniform float mFresnelPower;", "varying vec3 vNWorld;", "varying vec3 vI;", "varying float vWindForce;", THREE.ShaderChunk["color_pars_fragment"], THREE.ShaderChunk["map_pars_fragment"], THREE.ShaderChunk["lightmap_pars_fragment"], "#ifdef USE_ENVMAP", "varying vec3 vReflect;", "uniform float reflectivity;", "uniform samplerCube envMap;", "uniform float flipEnvMap;", "uniform int combine;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "uniform bool useRefract;", "uniform float refractionRatio;", "#endif", "#endif", THREE.ShaderChunk["fog_pars_fragment"], "varying vec3 vWorldPosition;", "varying vec3 vViewPosition;", "varying vec3 vNormal;", THREE.ShaderChunk["shadowmap_pars_fragment"], "#ifdef USE_NORMALMAP", "uniform sampler2D normalMap;", "uniform vec2 normalScale;", "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {", "vec3 q0 = dFdx( eye_pos.xyz );", "vec3 q1 = dFdy( eye_pos.xyz );", "vec2 st0 = dFdx( vUv.st );", "vec2 st1 = dFdy( vUv.st );", "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );", "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );", "vec3 N = normalize( surf_norm );", "vec3 nmap = texture2D( normalMap, vUv ).xyz;", "nmap.y = 1.0 - nmap.y;", "vec3 mapN = nmap * 2.0 - 1.0;", "mapN.xy = normalScale * mapN.xy;", "mat3 tsn = mat3( S, T, N );", "return normalize( tsn * mapN );", "}", "#endif", THREE.ShaderChunk["specularmap_pars_fragment"], "void main() {", "gl_FragColor = vec4( vec3 ( 1.0 ), opacity );", "#ifdef USE_MAP", "#ifdef GAMMA_INPUT", "vec4 texelColor = texture2D( map, vUv );", "texelColor.xyz *= texelColor.xyz;", "gl_FragColor = gl_FragColor * texelColor;", "#else", "gl_FragColor = gl_FragColor * texture2D( map, vUv );", "gl_FragColor.xyz *= 1.5;", "#endif", "#endif", THREE.ShaderChunk["alphatest_fragment"], THREE.ShaderChunk["specularmap_fragment"], "vec3 viewPosition = normalize( vViewPosition );", "vec3 normal = normalize( vNormal );", "#ifdef USE_ENVMAP", "vec3 reflectVec;", "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )", "normal = perturbNormal2Arb( -viewPosition, normal );", "vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );", "if ( useRefract ) {", "reflectVec = refract( cameraToVertex, normal, refractionRatio );", "} else { ", "reflectVec = reflect( cameraToVertex, normal );", "}", "#else", "reflectVec = vReflect;", "#endif", "#ifdef DOUBLE_SIDED", "float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );", "vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );", "#else", "vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );", "#endif", "#ifdef GAMMA_INPUT", "cubeColor.xyz *= cubeColor.xyz;", "#else", "cubeColor.xyz *= 2.0;", "#endif", "vec4 texelAux = texture2D( tAux, vUv );", "float fresnelChan = clamp(texelAux.r, 0.0, 1.0);", "float fresnelFact = clamp( mFresnelPower + (5.0 * (1.0 - texelAux.r)), 0.0, 5.0);", "#ifdef DOUBLE_SIDED", "float vFresnel = pow( 1.0 + dot( vI , flipNormal * normal ), fresnelFact );", "#else", "float vFresnel = pow( 1.0 + dot( vI , normal ), fresnelFact );", "#endif", "vFresnel = clamp( vFresnel, 0.0, 1.0 );", "#ifdef USE_SPECULARMAP", "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz * texelSpecular.xyz ,  vFresnel * specularStrength   );", "#else", "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz,  vFresnel * specularStrength  );", "#endif", "#endif", "#ifdef GAMMA_OUTPUT", "float d = 1.0/1.8;", "gl_FragColor.rgb = pow( gl_FragColor.rgb , vec3(d,d,d) );", "#endif", THREE.ShaderChunk["fog_fragment"], "}"].join("\n");

    return IFLPhongFresnelShader;

  })();

  NoiseShader = (function() {

    function NoiseShader() {}

    NoiseShader.prototype.uniforms = {
      "fTime": {
        type: "f",
        value: 1
      },
      "vScale": {
        type: "v2",
        value: new THREE.Vector2(1, 1)
      },
      "vOffset": {
        type: "v2",
        value: new THREE.Vector2(1, 1)
      }
    };

    NoiseShader.prototype.fragmentShader = ["uniform float fTime;", "varying vec2 vUv;", "vec4 permute( vec4 x ) {", "return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );", "}", "vec4 taylorInvSqrt( vec4 r ) {", "return 1.79284291400159 - 0.85373472095314 * r;", "}", "float snoise( vec3 v ) {", "const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );", "const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );", "vec3 i  = floor( v + dot( v, C.yyy ) );", "vec3 x0 = v - i + dot( i, C.xxx );", "vec3 g = step( x0.yzx, x0.xyz );", "vec3 l = 1.0 - g;", "vec3 i1 = min( g.xyz, l.zxy );", "vec3 i2 = max( g.xyz, l.zxy );", "vec3 x1 = x0 - i1 + 1.0 * C.xxx;", "vec3 x2 = x0 - i2 + 2.0 * C.xxx;", "vec3 x3 = x0 - 1. + 3.0 * C.xxx;", "i = mod( i, 289.0 );", "vec4 p = permute( permute( permute( i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );", "float n_ = 1.0 / 7.0;", "vec3 ns = n_ * D.wyz - D.xzx;", "vec4 j = p - 49.0 * floor( p * ns.z *ns.z );", "vec4 x_ = floor( j * ns.z );", "vec4 y_ = floor( j - 7.0 * x_ );", "vec4 x = x_ *ns.x + ns.yyyy;", "vec4 y = y_ *ns.x + ns.yyyy;", "vec4 h = 1.0 - abs( x ) - abs( y );", "vec4 b0 = vec4( x.xy, y.xy );", "vec4 b1 = vec4( x.zw, y.zw );", "vec4 s0 = floor( b0 ) * 2.0 + 1.0;", "vec4 s1 = floor( b1 ) * 2.0 + 1.0;", "vec4 sh = -step( h, vec4( 0.0 ) );", "vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;", "vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;", "vec3 p0 = vec3( a0.xy, h.x );", "vec3 p1 = vec3( a0.zw, h.y );", "vec3 p2 = vec3( a1.xy, h.z );", "vec3 p3 = vec3( a1.zw, h.w );", "vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );", "p0 *= norm.x;", "p1 *= norm.y;", "p2 *= norm.z;", "p3 *= norm.w;", "vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );", "m = m * m;", "return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) ) );", "}", "float surface3( vec3 coord ) {", "float n = 0.0;", "n += 1.0 * abs( snoise( coord ) );", "n += 0.5 * abs( snoise( coord * 2.0 ) );", "n += 0.25 * abs( snoise( coord * 4.0 ) );", "n += 0.125 * abs( snoise( coord * 8.0 ) );", "return n;", "}", "void main( void ) {", "vec3 coord = vec3( vUv, -fTime );", "float n = surface3( coord );", "gl_FragColor = vec4( vec3( n, n, n ), 1.0 );", "}"].join("\n");

    NoiseShader.prototype.vertexShader = ["varying vec2 vUv;", "uniform vec2 vScale;", "uniform vec2 vOffset;", "void main( void ) {", "vUv = (uv * vScale) + vOffset;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n");

    return NoiseShader;

  })();

  IFLLoader = (function() {

    IFLLoader.prototype.IFLVertexAttribute = {
      POSITION: 0,
      UV: 1,
      NORMALS: 2,
      TANGENTS: 3,
      BINORMALS: 4,
      TEX_TANGENTS: 5,
      TEX_BINORMALS: 6,
      COLOR: 7,
      JOINT_0: 8,
      JOINT_1: 9,
      JOINT_2: 10,
      JOINT_3: 11,
      JOINT_4: 12,
      JOINT_INDICES: 13,
      JOINT_WEIGHTS: 14,
      SECONDARY_UV: 15
    };

    IFLLoader.prototype.library = null;

    IFLLoader.prototype.callback = null;

    IFLLoader.prototype.callbackProgress = null;

    IFLLoader.prototype.worker = null;

    IFLLoader.prototype.convertTextureIndex = 0;

    IFLLoader.prototype.texCache = null;

    IFLLoader.prototype.matCache = null;

    IFLLoader.prototype.t = 0;

    IFLLoader.prototype.url = null;

    IFLLoader.prototype.loadingPhase = 0;

    IFLLoader.prototype.totalLoadingPhases = 4;

    IFLLoader.prototype.sky = null;

    function IFLLoader() {
      this.onXHRReadyStatusChange = __bind(this.onXHRReadyStatusChange, this);

      this.onXHRProgress = __bind(this.onXHRProgress, this);

      this.onWorkerMessage = __bind(this.onWorkerMessage, this);
      this.worker = new Worker('js/workers/iflworker.js');
      this.worker.onmessage = this.onWorkerMessage;
      this.texCache = {};
      this.matCache = {};
    }

    IFLLoader.prototype.onWorkerMessage = function(event) {
      var loaded, subtype, total;
      switch (event.data.type) {
        case "console":
          return console[event.data.action](event.data.msg);
        case "progress":
          loaded = event.data.data.progress;
          total = event.data.data.total;
          subtype = event.data.subtype;
          return this.handleProgress(loaded, total);
        default:
          return this[event.data.callback](event.data.data);
      }
    };

    IFLLoader.prototype.handleProgress = function(loaded, total) {
      var currentUnitBase, currentUnitProgress, totalLoaded, unit;
      if (this.callbackProgress != null) {
        unit = 100 / this.totalLoadingPhases;
        currentUnitBase = unit * this.loadingPhase;
        currentUnitProgress = (loaded * unit) / total;
        totalLoaded = currentUnitBase + currentUnitProgress;
        return this.callbackProgress(totalLoaded, 100);
      }
    };

    IFLLoader.prototype.load = function(url, callback, callbackProgress) {
      this.loadingPhase = 0;
      this.url = url;
      this.callback = callback;
      this.callbackProgress = callbackProgress;
      this.xhr = new XMLHttpRequest();
      this.xhr.onreadystatechange = this.onXHRReadyStatusChange;
      this.xhr.onprogress = this.onXHRProgress;
      this.xhr.open("GET", url, true);
      this.xhr.responseType = "arraybuffer";
      return this.xhr.send(null);
    };

    IFLLoader.prototype.onXHRProgress = function(event) {
      return this.handleProgress(event.loaded, event.total);
    };

    IFLLoader.prototype.onXHRReadyStatusChange = function() {
      var response, _ref;
      if (this.xhr.readyState === this.xhr.DONE) {
        if (this.xhr.status === 200 || this.xhr.status === 0) {
          response = (_ref = this.xhr.response) != null ? _ref : this.xhr.mozResponseArrayBuffer;
          this.decompressLibrary(response);
        } else {
          console.error("[ IFLLoader ]: Couldn't load [ " + url + " ] [ " + this.xhr.status + " ]");
        }
      }
    };

    IFLLoader.prototype.decompressLibrary = function(data) {
      this.t = new Date().getTime();
      this.loadingPhase++;
      return this.worker.postMessage({
        type: "inflate",
        data: data,
        callback: "parseLibrary"
      });
    };

    IFLLoader.prototype.parseLibrary = function(data) {
      if (data.length === 0) {
        throw "Error Decompressing Library, lenght is 0";
      }
      console.log(("[" + this.url + "] decompression time: ") + (new Date().getTime() - this.t) / 1000);
      this.loadingPhase++;
      this.t = new Date().getTime();
      return this.worker.postMessage({
        type: "convert_library",
        data: data,
        callback: "onLibraryParsed"
      });
    };

    IFLLoader.prototype.onLibraryParsed = function(data) {
      var content, func, _i, _len, _ref;
      this.library = data;
      for (func in this.IFLLibraryFuncs) {
        this.library[func] = this.IFLLibraryFuncs[func];
      }
      this.library._contentByID = {};
      _ref = this.library._content;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        content = _ref[_i];
        this.library._contentByID[content._reference.id] = content;
      }
      console.log(("[" + this.url + "] library parse time: ") + (new Date().getTime() - this.t) / 1000);
      this.t = new Date().getTime();
      this.loadingPhase++;
      return this.convertTextures();
    };

    IFLLoader.prototype.convertTextures = function() {
      var bmp, i, _i, _ref, _ref1;
      for (i = _i = _ref = this.convertTextureIndex, _ref1 = this.library._content.length; _i < _ref1; i = _i += 1) {
        if (this.library._content[i].iflType === "IFLBitmap") {
          bmp = this.library._content[i];
          this.convertTextureIndex = i + 1;
          if (bmp._hasOriginalByteArray) {
            this.worker.postMessage({
              type: "parse_jpg",
              image: bmp._savedBytes,
              w: bmp._width,
              h: bmp._height,
              callback: "onTextureConverted"
            });
          } else {
            this.worker.postMessage({
              type: "convert_argb",
              image: bmp._savedBytes,
              w: bmp._width,
              h: bmp._height,
              callback: "onTextureConverted"
            });
          }
          return;
        }
        this.handleProgress(i, this.library._content.length);
      }
      return this.createModel();
    };

    IFLLoader.prototype.onTextureConverted = function(data) {
      this.library._content[this.convertTextureIndex - 1].converted = data;
      return this.convertTextures();
    };

    IFLLoader.prototype.createModel = function() {
      var root, rootObject, rootObjects, _i, _len;
      console.log(("[" + this.url + "] convert textures time: ") + (new Date().getTime() - this.t) / 1000);
      this.t = new Date().getTime();
      root = new THREE.Object3D();
      rootObjects = this.library.getRootNodes();
      for (_i = 0, _len = rootObjects.length; _i < _len; _i++) {
        rootObject = rootObjects[_i];
        root.add(this.convertNode(rootObject));
      }
      console.log(("[" + this.url + "] convert node time: ") + (new Date().getTime() - this.t) / 1000);
      this.callback(root);
      this.worker.postMessage({
        type: "kill"
      });
    };

    IFLLoader.prototype.convertNode = function(iflnode) {
      var child, childID, mat, retEntity, _i, _len, _ref;
      switch (iflnode.iflType) {
        case "IFLMesh":
          retEntity = this.convertMesh(iflnode);
          break;
        default:
          retEntity = new THREE.Object3D();
      }
      retEntity.name = iflnode._reference.id;
      retEntity.matrix = this.convertMatrix4(iflnode._transformMatrix);
      retEntity.scale.getScaleFromMatrix(retEntity.matrix);
      mat = new THREE.Matrix4().extractRotation(retEntity.matrix);
      retEntity.rotation.setEulerFromRotationMatrix(retEntity.matrix, retEntity.eulerOrder);
      retEntity.position.getPositionFromMatrix(retEntity.matrix);
      _ref = iflnode.childIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childID = _ref[_i];
        child = this.library.getContent(childID.id);
        if (child) {
          retEntity.add(this.convertNode(child));
        }
      }
      return retEntity;
    };

    IFLLoader.prototype.convertMatrix4 = function(m) {
      return new THREE.Matrix4(m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]);
    };

    IFLLoader.prototype.convertMesh = function(iflmesh) {
      var bone, color_length, colors, geometry, index, isSkinnedMesh, material, normals, positions, ret, skinIndices, skinWeights, tangents, uvs, _i, _len, _ref;
      positions = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.POSITION];
      uvs = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.UV];
      normals = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.NORMALS];
      tangents = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.TEX_TANGENTS];
      colors = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.COLOR];
      color_length = 0;
      if (colors != null) {
        color_length = iflmesh.verticesDecomposed._vertexAttributeLengths[this.IFLVertexAttribute.COLOR];
      }
      skinWeights = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.JOINT_WEIGHTS];
      skinIndices = iflmesh.verticesDecomposed._data[this.IFLVertexAttribute.JOINT_INDICES];
      isSkinnedMesh = skinWeights && skinIndices;
      if (positions.length < 65535 && !isSkinnedMesh && iflmesh.subMeshes.length === 1) {
        geometry = this.convertBufferGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
      } else {
        geometry = this.convertGeometry(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices);
      }
      geometry.hasTangents = tangents != null;
      material = iflmesh.subMeshes.length === 1 ? geometry.materials[0] : new THREE.MeshFaceMaterial;
      material.skinning = isSkinnedMesh;
      if (isSkinnedMesh) {
        ret = new THREE.SkinnedMesh(geometry, material);
      } else {
        ret = new THREE.Mesh(geometry, material);
      }
      if (isSkinnedMesh) {
        _ref = ret.geometry.bones;
        for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
          bone = _ref[index];
          ret.boneInverses[index] = bone.invBindMatrix;
        }
      }
      ret.castShadow = ret.receiveShadow = true;
      return ret;
    };

    IFLLoader.prototype.convertBufferGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
      var geometry, indexBuffer;
      geometry = new THREE.BufferGeometry;
      indexBuffer = iflmesh.subMeshes[0].indexBuffer._rawData;
      geometry.attributes = {};
      geometry.attributes.index = {
        itemSize: 1,
        array: new Int16Array(indexBuffer.length),
        numItems: indexBuffer.length
      };
      geometry.attributes.index.array.set(indexBuffer);
      geometry.attributes.position = {
        itemSize: 3,
        array: positions,
        numItems: positions.length
      };
      if (uvs) {
        geometry.attributes.uv = {
          itemSize: 2,
          array: uvs,
          numItems: uvs.length
        };
      }
      if (normals) {
        geometry.attributes.normal = {
          itemSize: 3,
          array: normals,
          numItems: normals.length
        };
      }
      if (colors) {
        geometry.attributes.color = {
          itemSize: color_length,
          array: colors,
          numItems: colors.length
        };
      }
      if (tangents) {
        geometry.attributes.tangent = {
          itemSize: 3,
          array: tangents,
          numItems: tangents.length
        };
      }
      geometry.offsets = [
        {
          start: 0,
          count: indexBuffer.length,
          index: 0
        }
      ];
      geometry.materials = [this.convertMaterial(iflmesh.subMeshes[0], iflmesh._reference.id)];
      return geometry;
    };

    IFLLoader.prototype.convertGeometry = function(iflmesh, positions, uvs, normals, tangents, colors, color_length, isSkinnedMesh, skinWeights, skinIndices) {
      var cachedColors, cachedNormals, cachedPositions, cachedTangents, cachedUVs, face, faceIndex, fakeUV, fvUVs, geometry, i, i1, i12, i13, i14, i2, i22, i23, i24, i3, i32, i33, i34, ib, ibi, material, p1, p2, p3, positionRearrangment, reasons, second, stepSize, subMesh, subMeshIndex, _i, _j, _k, _l, _len, _len1, _ref, _ref1, _ref2, _step;
      reasons = "";
      if (positions.length >= 65535) {
        reasons += "[Vertices > 65535]";
      }
      if (isSkinnedMesh) {
        reasons += "[Is Skinned Mesh]";
      }
      if (iflmesh.subMeshes.length > 1) {
        reasons += "[Has Submeshes]";
      }
      if (colors != null) {
        reasons += "[Has Vertex Colors]";
      }
      console.info("Mesh " + iflmesh._reference.id + " converted as standard THREE.Geometry because " + reasons);
      geometry = new THREE.Geometry;
      cachedUVs = [];
      cachedNormals = [];
      cachedTangents = [];
      cachedColors = [];
      cachedPositions = {};
      positionRearrangment = {};
      if (positions) {
        for (i = _i = 0, _ref = positions.length; _i < _ref; i = _i += 3) {
          p1 = positions[i];
          p2 = positions[i + 1];
          p3 = positions[i + 2];
          if (!cachedPositions[p1 + "_" + p2 + "_" + p3]) {
            cachedPositions[p1 + "_" + p2 + "_" + p3] = {
              index: geometry.vertices.length,
              vertex: new THREE.Vector3(p1, p2, p3)
            };
            geometry.vertices.push(cachedPositions[p1 + "_" + p2 + "_" + p3].vertex);
          }
          positionRearrangment[i / 3] = cachedPositions[p1 + "_" + p2 + "_" + p3].index;
        }
      } else {
        return new THREE.Object3D();
      }
      if (isSkinnedMesh) {
        stepSize = iflmesh.verticesDecomposed._vertexAttributeLengths[this.IFLVertexAttribute.JOINT_INDICES];
        if (stepSize <= 2) {
          for (i = _j = 0, _ref1 = skinIndices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = _j += stepSize) {
            second = Math.floor(i + stepSize / 2);
            geometry.skinWeights.push(new THREE.Vector4(skinWeights[i], skinWeights[second], 0, 0));
            geometry.skinIndices.push(new THREE.Vector4(skinIndices[i], skinIndices[second], 0, 0));
          }
        }
        geometry.bones = this.convertBones(iflmesh);
        geometry.animation = this.convertAnimations(geometry.bones, iflmesh);
      }
      fakeUV = new THREE.UV(0, 0);
      _ref2 = iflmesh.subMeshes;
      for (subMeshIndex = _k = 0, _len = _ref2.length; _k < _len; subMeshIndex = ++_k) {
        subMesh = _ref2[subMeshIndex];
        material = this.convertMaterial(subMesh, iflmesh._reference.id);
        material.skinning = isSkinnedMesh;
        geometry.materials.push(material);
        ib = subMesh.indexBuffer._rawData;
        for (ibi = _l = 0, _len1 = ib.length, _step = 3; _l < _len1; ibi = _l += _step) {
          i1 = ib[ibi];
          i2 = ib[ibi + 1];
          i3 = ib[ibi + 2];
          i12 = i1 * 2;
          i22 = i2 * 2;
          i32 = i3 * 2;
          i13 = i1 * 3;
          i23 = i2 * 3;
          i33 = i3 * 3;
          i14 = i1 * 4;
          i24 = i2 * 4;
          i34 = i3 * 4;
          face = new THREE.Face3(positionRearrangment[i1], positionRearrangment[i2], positionRearrangment[i3], null, null, subMeshIndex);
          faceIndex = geometry.faces.length;
          fvUVs = geometry.faceVertexUvs[0][faceIndex] = [];
          if (uvs != null) {
            fvUVs.push(cachedUVs[i12] ? cachedUVs[i12] : cachedUVs[i12] = new THREE.UV(uvs[i12], uvs[i12 + 1]));
            fvUVs.push(cachedUVs[i22] ? cachedUVs[i22] : cachedUVs[i22] = new THREE.UV(uvs[i22], uvs[i22 + 1]));
            fvUVs.push(cachedUVs[i32] ? cachedUVs[i32] : cachedUVs[i32] = new THREE.UV(uvs[i32], uvs[i32 + 1]));
          }
          if (normals != null) {
            face.vertexNormals.push(cachedNormals[i13] ? cachedNormals[i13] : cachedNormals[i13] = new THREE.Vector3(normals[i13], normals[i13 + 1], normals[i13 + 2]));
            face.vertexNormals.push(cachedNormals[i23] ? cachedNormals[i23] : cachedNormals[i23] = new THREE.Vector3(normals[i23], normals[i23 + 1], normals[i23 + 2]));
            face.vertexNormals.push(cachedNormals[i33] ? cachedNormals[i33] : cachedNormals[i33] = new THREE.Vector3(normals[i33], normals[i33 + 1], normals[i33 + 2]));
          }
          if (tangents != null) {
            face.vertexTangents.push(cachedTangents[i13] ? cachedTangents[i13] : cachedTangents[i13] = new THREE.Vector4(tangents[i13], tangents[i13 + 1], tangents[i13 + 2], 1));
            face.vertexTangents.push(cachedTangents[i23] ? cachedTangents[i23] : cachedTangents[i23] = new THREE.Vector4(tangents[i23], tangents[i23 + 1], tangents[i23 + 2], 1));
            face.vertexTangents.push(cachedTangents[i33] ? cachedTangents[i33] : cachedTangents[i33] = new THREE.Vector4(tangents[i33], tangents[i33 + 1], tangents[i33 + 2], 1));
          }
          if (colors != null) {
            if (color_length === 3) {
              face.vertexColors.push(cachedColors[i13] ? cachedColors[i13] : cachedColors[i13] = new THREE.Color().setRGB(colors[i13], colors[i13 + 1], colors[i13 + 2]));
              face.vertexColors.push(cachedColors[i23] ? cachedColors[i23] : cachedColors[i23] = new THREE.Color().setRGB(colors[i23], colors[i23 + 1], colors[i23 + 2]));
              face.vertexColors.push(cachedColors[i33] ? cachedColors[i33] : cachedColors[i33] = new THREE.Color().setRGB(colors[i33], colors[i33 + 1], colors[i33 + 2]));
            }
            if (color_length === 4) {
              face.vertexColors.push(cachedColors[i14] ? cachedColors[i14] : cachedColors[i14] = new THREE.Color().setRGB(colors[i14], colors[i14 + 1], colors[i14 + 2]));
              face.vertexColors.push(cachedColors[i24] ? cachedColors[i24] : cachedColors[i24] = new THREE.Color().setRGB(colors[i24], colors[i24 + 1], colors[i24 + 2]));
              face.vertexColors.push(cachedColors[i34] ? cachedColors[i34] : cachedColors[i34] = new THREE.Color().setRGB(colors[i34], colors[i34 + 1], colors[i34 + 2]));
            }
          }
          geometry.faces.push(face);
        }
      }
      if (isSkinnedMesh) {
        geometry.computeCentroids();
        geometry.computeFaceNormals();
        try {
          geometry.computeTangents();
        } catch (e) {
          console.warn("error computing tangents");
        }
      }
      return geometry;
    };

    IFLLoader.prototype.convertBones = function(iflmesh) {
      var bind, bindingToJoint, bindings, bindpose, decomp, i, iflparent, invBindMatrix, jo, joint, jointMatrix, jointToBinding, jointToIndex, joints, p, parent, pos, root, rotq, scale, sk, skeletonJoint, _i, _j, _k, _l, _len, _m, _ref, _ref1, _ref2, _ref3;
      joints = [];
      jointToBinding = [];
      bindingToJoint = [];
      bindings = iflmesh.jointBindings;
      for (i = _i = 0, _ref = bindings.length; _i < _ref; i = _i += 1) {
        jo = this.library.getContent(bindings[i].jointID.id);
        if (!(jo != null)) {
          return null;
        }
        jointToBinding[jo._reference.id] = i;
        bindingToJoint[i] = jo._reference.id;
        joints.push(jo);
      }
      for (_j = 0, _len = joints.length; _j < _len; _j++) {
        joint = joints[_j];
        if (!this.library.findJointParent(joint)) {
          root = joint;
          break;
        }
      }
      bindpose = this.convertMatrix4(iflmesh.bindPoseMatrix);
      sk = [];
      sk.name = root.id;
      jointToIndex = [];
      skeletonJoint;

      for (i = _k = 0, _ref1 = bindings.length; _k < _ref1; i = _k += 1) {
        skeletonJoint = {};
        skeletonJoint.name = joints[i]._reference.id;
        jointMatrix = this.convertMatrix4(joints[i]._transformMatrix);
        invBindMatrix = this.convertMatrix4(bindings[i].inverseBindMatrix);
        decomp = jointMatrix.decompose();
        skeletonJoint.pos = [decomp[0].x, decomp[0].y, decomp[0].z];
        skeletonJoint.rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
        jointToIndex[skeletonJoint.name] = sk.length;
        skeletonJoint.invBindMatrix = invBindMatrix;
        skeletonJoint.jointMatrix = jointMatrix;
        sk.push(skeletonJoint);
      }
      for (i = _l = 0, _ref2 = bindings.length; _l < _ref2; i = _l += 1) {
        skeletonJoint = sk[i];
        parent = this.library.findJointParent(joints[i]);
        if (!(parent != null)) {
          skeletonJoint.parent = -1;
        } else {
          if (parent.iflType === "IFLJoint") {
            if (jointToIndex[parent._reference.id] !== void 0) {
              skeletonJoint.parent = jointToIndex[parent._reference.id];
            } else {
              skeletonJoint.parent = -1;
            }
          } else {
            skeletonJoint.parent = -1;
          }
        }
      }
      for (i = _m = 0, _ref3 = bindings.length; _m < _ref3; i = _m += 1) {
        skeletonJoint = sk[i];
        bind = skeletonJoint.invBindMatrix.clone();
        scale = this.setScale1(bind);
        bind.getInverse(bind);
        if (i !== 0) {
          p = sk[skeletonJoint.parent];
          bind.multiply(p.invBindMatrix, bind);
          iflparent = this.library.findParent(this.library.getContent(skeletonJoint.name));
          if (iflparent.iflType !== "IFLJoint") {
            this.prependNonJointParents(bind, iflparent);
          }
        } else {
          bind.multiply(bindpose, bind);
        }
        decomp = bind.decompose();
        pos = [decomp[0].x, decomp[0].y, decomp[0].z];
        rotq = [decomp[1].x, decomp[1].y, decomp[1].z, decomp[1].w];
        skeletonJoint.pos = pos;
        skeletonJoint.rotq = rotq;
      }
      return sk;
    };

    IFLLoader.prototype.prependNonJointParents = function(bind, iflparent) {
      var otherparent, parentmat, prepended;
      parentmat = this.convertMatrix4(iflparent._transformMatrix);
      prepended = new THREE.Matrix4().multiply(parentmat, bind);
      bind.copy(prepended);
      otherparent = this.library.findParent(iflparent);
      if (otherparent.iflType !== "IFLJoint") {
        return this.prependNonJointParents(bind, otherparent);
      }
    };

    IFLLoader.prototype.setScale1 = function(m) {
      var x, y, z;
      x = new THREE.Vector3(m.elements[0], m.elements[1], m.elements[2]).length();
      y = new THREE.Vector3(m.elements[4], m.elements[5], m.elements[6]).length();
      z = new THREE.Vector3(m.elements[8], m.elements[9], m.elements[10]).length();
      m.elements[0] /= x;
      m.elements[1] /= x;
      m.elements[2] /= x;
      m.elements[4] /= y;
      m.elements[5] /= y;
      m.elements[6] /= y;
      m.elements[8] /= z;
      m.elements[9] /= z;
      m.elements[10] /= z;
      m.elements[12] /= x;
      m.elements[13] /= y;
      m.elements[14] /= z;
      m.elements[15] = 1;
      return new THREE.Vector3(x, y, z);
    };

    IFLLoader.prototype.findJointParent = function(joint, root) {
      var childID, p, _i, _len, _ref;
      if (!(root != null)) {
        return null;
      }
      _ref = root.childIDs;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        childID = _ref[_i];
        if (childID.id === joint._reference.id) {
          return root;
        } else {
          p = findJointParent(joint, this.library.getContent(childID.id));
          if (p) {
            return p;
          }
        }
      }
      return null;
    };

    IFLLoader.prototype.convertAnimations = function(skeleton, iflMesh) {
      var anim, anim3js, anims, bindpose, firstKey, i, j, k, key3js, keys, lastkey, maxTime, numTimes, r, sampler, stillMatDec, stillPos, stillRot, timePerFrame, totalMaxTime, track, track3js, trackLength, _i, _j, _k, _l, _m, _ref, _ref1, _ref2, _ref3;
      anims = this.library.getAnimationsForSkinJoints(iflMesh);
      r = [];
      bindpose = this.convertMatrix4(iflMesh.bindPoseMatrix);
      if (anims.length === 0) {
        anims[0] = {
          _reference: {
            id: "fake"
          },
          tracks: []
        };
      }
      for (i = _i = 0; _i < 1; i = _i += 1) {
        anim3js = {};
        anim3js.name = iflMesh._reference.id + "_" + anims[i]._reference.id;
        anim3js.fps = 30;
        anim3js.hierarchy = [];
        totalMaxTime = 0;
        for (k = _j = 0, _ref = skeleton.length; _j < _ref; k = _j += 1) {
          track = this.getTrackForJoint(skeleton[k], anims[i]);
          stillMatDec = skeleton[k].jointMatrix.decompose();
          maxTime = 0;
          stillPos = skeleton[k].pos;
          stillRot = skeleton[k].rotq;
          if (track != null) {
            track3js = {};
            track3js.parent = skeleton[k].parent;
            track3js.name = "track_" + skeleton[k].name;
            track3js.keys = [];
            sampler = track.sampler;
            trackLength = track.end - track.start;
            numTimes = sampler.times.length;
            timePerFrame = (trackLength / numTimes) * 1000;
            for (j = _k = 0, _ref1 = sampler.times.length; _k < _ref1; j = _k += 1) {
              key3js = {};
              key3js.time = sampler.times[j];
              maxTime = Math.max(key3js.time, maxTime);
              totalMaxTime = Math.max(maxTime, totalMaxTime);
              key3js.pos = [sampler.positions[j].x, sampler.positions[j].y, sampler.positions[j].z];
              key3js.rot = [sampler.orientations[j].x, sampler.orientations[j].y, sampler.orientations[j].z, sampler.orientations[j].w];
              key3js.scl = [1, 1, 1];
              track3js.keys.push(key3js);
            }
          } else {
            console.log("no track for joint " + skeleton[k].name + " creating a fake one");
            anim = anims[i];
            sampler = anim.tracks.length > 0 ? anim.tracks[0].sampler : {
              times: [0, 1]
            };
            track3js = {};
            track3js.name = "fake_track_" + skeleton[k].name;
            track3js.parent = skeleton[k].parent;
            track3js.keys = [];
            for (j = _l = 0, _ref2 = sampler.times.length; _l < _ref2; j = _l += 1) {
              key3js = {};
              key3js.time = sampler.times[j];
              maxTime = Math.max(key3js.time, maxTime);
              totalMaxTime = Math.max(maxTime, totalMaxTime);
              key3js.pos = [stillPos[0], stillPos[1], stillPos[2]];
              key3js.rot = [stillRot[0], stillRot[1], stillRot[2], stillRot[3]];
              key3js.scl = [1, 1, 1];
              track3js.keys.push(key3js);
            }
          }
          anim3js.length = maxTime;
          anim3js.hierarchy.push(track3js);
        }
        for (k = _m = 0, _ref3 = anim3js.hierarchy.length; _m < _ref3; k = _m += 1) {
          keys = anim3js.hierarchy[k].keys;
          lastkey = keys[keys.length - 1];
          firstKey = keys[0];
          if (lastkey.time < totalMaxTime) {
            keys.push({
              time: totalMaxTime,
              pos: lastkey.pos,
              rot: lastkey.rot,
              scl: lastkey.scl
            });
          }
          if (firstKey.time > 0) {
            keys.unshift({
              time: 0,
              pos: firstKey.pos,
              rot: firstKey.rot,
              scl: firstKey.scl
            });
          }
        }
        anim3js.length = totalMaxTime;
        r.push(anim3js);
      }
      return r[0];
    };

    IFLLoader.prototype.getTrackForJoint = function(joint, anim) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = anim.tracks.length; _i < _ref; i = _i += 1) {
        if (anim.tracks[i].target.id === joint.name) {
          return anim.tracks[i];
        }
      }
      return null;
    };

    IFLLoader.prototype.convertMaterial = function(subMesh, meshname) {
      var matid;
      matid = subMesh.material._reference.id;
      if (!this.matCache[matid]) {
        this.matCache[matid] = this.convertGenericMaterial(subMesh);
      }
      return this.matCache[matid];
    };

    IFLLoader.prototype.getMaterialParams = function(subMesh) {
      var params;
      params = {
        color: 0xFFFFFF,
        ambient: 0xFFFFFF,
        specular: 0xFFFFFF,
        map: this.getSubmeshTexture(subMesh.diffuseTextures),
        lightMap: null,
        bumpMap: null,
        reflectivity: 0,
        shininess: 30,
        opacity: 1,
        wireframe: false,
        side: THREE.DoubleSide,
        depthWrite: true,
        transparent: false,
        lights: false,
        combine: false
      };
      return params;
    };

    IFLLoader.prototype.convertGenericMaterial = function(subMesh) {
      var mat, params, _ref;
      params = this.getMaterialParams(subMesh);
      mat = new THREE.MeshLambertMaterial(params);
      mat.transparent = (_ref = params.map) != null ? _ref.transparent : void 0;
      return mat;
    };

    IFLLoader.prototype.getSubmeshTexture = function(from) {
      if (from.length > 0) {
        return this.getTexture(from[0].id, false);
      }
      return null;
    };

    IFLLoader.prototype.getTexture = function(id) {
      var ret, tex;
      tex = this.library.getContent(id);
      if ((tex != null ? tex.converted : void 0) != null) {
        this.texCache[tex._reference.id] = ret = new THREE.DataTexture(tex.converted, tex._width, tex._height, tex._hasOriginalByteArray ? THREE.RGBFormat : THREE.RGBAFormat);
      }
      if (ret) {
        ret.needsUpdate = true;
        ret.flipY = false;
        ret.transparent = tex.transparent;
      }
      return ret;
    };

    IFLLoader.prototype.getCubeTexture = function(array) {
      var image, images, index, path, tex, texture, _i, _len;
      images = [];
      texture = new THREE.Texture();
      texture.image = images;
      texture.flipY = false;
      for (index = _i = 0, _len = array.length; _i < _len; index = ++_i) {
        path = array[index];
        tex = this.getTexture(path);
        image = tex.image;
        image.format = tex.format;
        images[index] = image;
      }
      texture.needsUpdate = true;
      return texture;
    };

    IFLLoader.prototype.IFLLibraryFuncs = {
      getContent: function(id) {
        return this._contentByID[id];
      },
      getRootNodes: function() {
        return this.getRootNodesIn(this._content);
      },
      isIFLNode: function(object) {
        return object.iflType === "IFLNode" || object.iflType === "IFLJoint" || object.iflType === "IFLMesh" || object.iflType === "IFLMeshContainer" || object.iflType === "IFLLight" || object.iflType === "IFLCamera";
      },
      getDiffuseTexture: function(subMesh) {
        return this.getContent(subMesh._diffuseTextures[0].id);
      },
      getRootNodesIn: function(lib) {
        var k, m, meshesChildrenOfSomeone, meshesNotChildrenOfSomeone, tm, _i, _j, _len, _len1, _ref;
        meshesChildrenOfSomeone = [];
        meshesNotChildrenOfSomeone = [];
        for (_i = 0, _len = lib.length; _i < _len; _i++) {
          tm = lib[_i];
          if (!(this.isIFLNode(tm))) {
            continue;
          }
          if (meshesChildrenOfSomeone.indexOf(tm._reference.id) === -1) {
            meshesNotChildrenOfSomeone.push(tm._reference.id);
          }
          _ref = tm.childIDs;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            m = _ref[_j];
            if (meshesNotChildrenOfSomeone.indexOf(m.id) !== -1) {
              meshesNotChildrenOfSomeone.splice(meshesNotChildrenOfSomeone.indexOf(m.id), 1);
            }
            meshesChildrenOfSomeone.push(m.id);
          }
        }
        return (function() {
          var _k, _ref1, _results;
          _results = [];
          for (k = _k = 0, _ref1 = meshesNotChildrenOfSomeone.length; _k < _ref1; k = _k += 1) {
            _results.push(this.getContent(meshesNotChildrenOfSomeone[k]));
          }
          return _results;
        }).call(this);
      },
      isRoot: function(contentID) {
        return this.isRootWithin(contentID, this._content);
      },
      isRootWithin: function(contentID, context) {
        var childID, content, _i, _j, _len, _len1, _ref;
        for (_i = 0, _len = context.length; _i < _len; _i++) {
          content = context[_i];
          if (this.isIFLNode(content)) {
            _ref = content.childIDs;
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              childID = _ref[_j];
              if (childID.id === contentID) {
                return false;
              }
            }
          }
        }
        return true;
      },
      findParent: function(node, parent) {
        var ch, childID, p, rootNode, rootNodes, _i, _j, _len, _len1, _ref;
        if (!(parent != null)) {
          rootNodes = this.getRootNodes();
          for (_i = 0, _len = rootNodes.length; _i < _len; _i++) {
            rootNode = rootNodes[_i];
            p = this.findParent(node, rootNode);
            if (p != null) {
              return p;
            }
          }
        } else {
          _ref = parent.childIDs;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            childID = _ref[_j];
            if (childID.id === node._reference.id) {
              return parent;
            } else {
              ch = this.getContent(childID.id);
              if (ch) {
                p = this.findParent(node, ch);
                if (p != null) {
                  return p;
                }
              }
            }
          }
        }
        return null;
      },
      getAnimationsForSkinJoints: function(skin) {
        var animRet, doneAnims, jobj, joint, jointAnimation, jointAnimations, r, track, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
        r = [];
        doneAnims = [];
        _ref = skin.jointBindings;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          jobj = _ref[_i];
          joint = jobj.jointID;
          jointAnimations = this.getAnimationsForID(joint.id, false);
          if ((jointAnimations != null)) {
            for (_j = 0, _len1 = jointAnimations.length; _j < _len1; _j++) {
              jointAnimation = jointAnimations[_j];
              if (!doneAnims[jointAnimation._reference.id]) {
                doneAnims[jointAnimation._reference.id] = {
                  tracks: [],
                  iflType: "IFLAnimation"
                };
                doneAnims[jointAnimation._reference.id]._reference = {
                  id: jointAnimation._reference.id,
                  iflType: "IFLID"
                };
                r.push(doneAnims[jointAnimation._reference.id]);
              }
              animRet = doneAnims[jointAnimation._reference.id];
              _ref1 = jointAnimation.tracks;
              for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                track = _ref1[_k];
                if (animRet.tracks.indexOf(track) === -1) {
                  animRet.tracks.push(track);
                }
              }
            }
          }
        }
        return r;
      },
      getAnimationsForID: function(id) {
        var animation, r, track, tracks, _i, _j, _len, _len1, _ref;
        r = [];
        _ref = this._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          animation = _ref[_i];
          if (!(animation.iflType === "IFLAnimation")) {
            continue;
          }
          tracks = animation.tracks;
          for (_j = 0, _len1 = tracks.length; _j < _len1; _j++) {
            track = tracks[_j];
            if (track.target.id === id && r.indexOf(animation) === -1) {
              r.push(animation);
            }
          }
        }
        if (r.length > 0) {
          return r;
        }
        return null;
      },
      findJointParent: function(node) {
        var childID, content, _i, _j, _len, _len1, _ref, _ref1;
        _ref = this._content;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          content = _ref[_i];
          if (this.isIFLNode(content)) {
            _ref1 = content.childIDs;
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              childID = _ref1[_j];
              if (childID.id === node._reference.id) {
                if (content.iflType === "IFLJoint") {
                  return content;
                } else {
                  return this.findJointParent(content);
                }
              }
            }
          }
        }
        return null;
      }
    };

    return IFLLoader;

  })();

  App = (function() {

    App.prototype.container = null;

    App.prototype.stats = null;

    App.prototype.camera = null;

    App.prototype.scene = null;

    App.prototype.renderer = null;

    App.prototype.controls = null;

    App.prototype.clock = null;

    App.prototype.renderTarget = null;

    App.prototype.composer = null;

    App.prototype.skyCubeTexture = null;

    App.prototype.skyCube = null;

    App.prototype.terrainLoader = null;

    App.prototype.skyLoader = null;

    App.prototype.noiseMap = null;

    App.prototype.noiseShader = null;

    App.prototype.noiseScene = null;

    App.prototype.noiseMaterial = null;

    App.prototype.noiseCameraOrtho = null;

    App.prototype.noiseQuadTarget = null;

    App.prototype.noiseRenderTarget = null;

    App.prototype.noiseSpeed = 0.046;

    App.prototype.noiseOffsetSpeed = 0.11;

    App.prototype.windDirection = new THREE.Vector3(0.8, 0.1, 0.1);

    function App() {
      this.onWindowResize = __bind(this.onWindowResize, this);

      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);

      this.onWindDirectionChange = __bind(this.onWindDirectionChange, this);

      this.onTerrainLoaded = __bind(this.onTerrainLoaded, this);

      this.onTerrainProgress = __bind(this.onTerrainProgress, this);

      this.initSky = __bind(this.initSky, this);

      var ambient, directional;
      this.clock = new THREE.Clock();
      this.container = document.createElement('div');
      document.body.appendChild(this.container);
      this.renderer = new THREE.WebGLRenderer({
        antialias: false
      });
      this.renderer.autoClear = false;
      this.renderer.gammaOutput = false;
      this.renderer.gammaInput = false;
      this.renderer.sortObjects = false;
      this.renderer.shadowMapEnabled = false;
      this.renderer.shadowMapSoft = true;
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      this.camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 5000);
      this.camera.position.x = 5;
      this.camera.position.y = 10;
      this.camera.position.z = 40;
      this.scene = new THREE.Scene();
      ambient = new THREE.AmbientLight(0xFFFFFF);
      this.scene.add(ambient);
      directional = new THREE.DirectionalLight;
      directional.position.set(100, 100, 100);
      this.scene.add(directional);
      this.onWindowResize();
      this.noiseMap = new THREE.WebGLRenderTarget(256, 256, {
        minFilter: THREE.LinearMipmapLinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBFormat
      });
      this.noiseShader = new NoiseShader();
      this.noiseShader.uniforms.vScale.value.set(0.3, 0.3);
      this.noiseScene = new THREE.Scene();
      this.noiseCameraOrtho = new THREE.OrthographicCamera(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, -10000, 10000);
      this.noiseCameraOrtho.position.z = 100;
      this.noiseScene.add(this.noiseCameraOrtho);
      this.noiseMaterial = new THREE.ShaderMaterial({
        fragmentShader: this.noiseShader.fragmentShader,
        vertexShader: this.noiseShader.vertexShader,
        uniforms: this.noiseShader.uniforms,
        lights: false
      });
      this.noiseQuadTarget = new THREE.Mesh(new THREE.PlaneGeometry(window.innerWidth, window.innerHeight, 100, 100), this.noiseMaterial);
      this.noiseQuadTarget.position.z = -500;
      this.noiseScene.add(this.noiseQuadTarget);
      this.initSky();
      this.terrainLoader = new IFLLoader();
      this.terrainLoader.load("models/wind.if3d", this.onTerrainLoaded, this.onTerrainProgress);
      this.container.appendChild(this.renderer.domElement);
      this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
      this.controls.enabled = true;
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      this.container.appendChild(this.stats.domElement);
      window.addEventListener('resize', this.onWindowResize, false);
      this.animate();
      $("body").append("<div id='loading'>Loading Resources<div>");
      $("#loading").append("<div id='progressbar'></div>");
      $("#progressbar").progressbar({
        value: 0
      });
      this.onWindowResize();
      return;
    }

    App.prototype.initSky = function(iflscene) {
      var format, geom, material, path, urls;
      geom = new THREE.CubeGeometry(2000, 2000, 2000);
      path = "models/";
      format = '.png';
      urls = [path + 'posx' + format, path + 'negx' + format, path + 'posy' + format, path + 'negy' + format, path + 'negz' + format, path + 'posz' + format];
      this.skyCubeTexture = THREE.ImageUtils.loadTextureCube(urls, null, onload);
      this.skyCubeTexture.format = THREE.RGBFormat;
      this.cubeShader = THREE.ShaderUtils.lib["cube"];
      this.cubeShader.uniforms["tCube"].value = this.skyCubeTexture;
      this.cubeShader.uniforms["tFlip"].value = true;
      material = new THREE.ShaderMaterial({
        fragmentShader: this.cubeShader.fragmentShader,
        vertexShader: this.cubeShader.vertexShader,
        uniforms: this.cubeShader.uniforms,
        depthWrite: false,
        side: THREE.BackSide
      });
      this.skyCube = new THREE.Mesh(geom, material);
      this.skyCube.name = "skyCube";
      this.scene.add(this.skyCube);
    };

    App.prototype.onTerrainProgress = function(loaded, total) {
      return $("#progressbar").progressbar("option", "value", (loaded * 100) / total);
    };

    App.prototype.onTerrainLoaded = function(iflscene) {
      var child, fresnelMat, h, max, min, plane, w, _i, _len, _ref;
      min = new THREE.Vector2();
      max = new THREE.Vector2();
      fresnelMat = this.createFresnelMaterial();
      _ref = iflscene.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        child = _ref[_i];
        if (child.position.x < min.x) {
          min.x = child.position.x;
        }
        if (child.position.z < min.y) {
          min.y = child.position.z;
        }
        if (child.position.x > max.x) {
          max.x = child.position.x;
        }
        if (child.position.z > max.y) {
          max.y = child.position.z;
        }
        child.material = fresnelMat;
      }
      w = max.x - min.x;
      h = max.y - min.y;
      plane = new THREE.Mesh(new THREE.PlaneGeometry(w, h, 2, 2), new THREE.MeshPhongMaterial({
        map: this.noiseMap,
        lights: false
      }));
      plane.visible = false;
      plane.position.x = min.x + w / 2;
      plane.position.z = min.y + h / 2;
      plane.rotation.x = -Math.PI / 2;
      this.scene.add(plane);
      fresnelMat.uniforms.windMin.value.copy(min);
      fresnelMat.uniforms.windSize.value.set(w, h);
      fresnelMat.uniforms.windDirection.value = this.windDirection;
      this.scene.add(iflscene);
      $("#loading").remove();
      this.gui = new dat.GUI({
        width: 400
      });
      this.gui.add(plane, "visible").name("Show Turbulence Plane");
      this.gui.add(this.noiseShader.uniforms.vScale.value, "x", 0, 1).name("Wind Turbulence Scale X");
      this.gui.add(this.noiseShader.uniforms.vScale.value, "y", 0, 1).name("Wind Turbulence Scale Y");
      this.gui.add(this, "noiseSpeed", 0, 1).name("Wind Turbolence Speed");
      this.gui.add(this, "noiseOffsetSpeed", 0, 1).name("Wind Offset Speed");
      this.gui.add(fresnelMat.uniforms.windScale, "value", 0, 10).name("Wind Power");
      this.xcont = this.gui.add(this.windDirection, "x", -1, 1).step(0.01).name("Wind Direction X").onChange(this.onWindDirectionChange);
      this.ycont = this.gui.add(this.windDirection, "y", -1, 1).step(0.01).name("Wind Direction Y").onChange(this.onWindDirectionChange);
      this.zcont = this.gui.add(this.windDirection, "z", -1, 1).step(0.01).name("Wind Direction Z").onChange(this.onWindDirectionChange);
      this.windDirection.x = 1;
      this.windDirection.y = 0;
      this.windDirection.z = 0;
      this.onWindDirectionChange();
      return null;
    };

    App.prototype.onWindDirectionChange = function(value) {
      this.windDirection.normalize();
      this.xcont.updateDisplay();
      this.ycont.updateDisplay();
      return this.zcont.updateDisplay();
    };

    App.prototype.createFresnelMaterial = function() {
      var material, params, shader, uniforms;
      shader = new IFLPhongFresnelShader;
      uniforms = shader.uniforms;
      params = {};
      params.fragmentShader = shader.fragmentShader;
      params.vertexShader = shader.vertexShader;
      params.uniforms = uniforms;
      params.vertexColors = THREE.VertexColors;
      material = new THREE.ShaderMaterial(params);
      material.lights = false;
      uniforms["diffuse"].value = new THREE.Color(0xFF0000);
      uniforms["ambient"].value = new THREE.Color(0x111111);
      uniforms["specular"].value = new THREE.Color(0x000000);
      uniforms["map"].value = material.map = THREE.ImageUtils.loadTexture("models/posy.png");
      uniforms["envMap"].value = material.envMap = this.skyCubeTexture;
      uniforms["tWindForce"].value = this.noiseMap;
      uniforms["windScale"].value = 1;
      return material;
    };

    App.prototype.animate = function() {
      window.requestAnimationFrame(this.animate);
      this.render();
      this.stats.update();
    };

    App.prototype.render = function() {
      var delta, _ref, _ref1;
      delta = this.clock.getDelta();
      this.renderer.clear();
      if (this.windDirection) {
        this.noiseShader.uniforms["fTime"].value += delta * this.noiseSpeed;
        this.noiseShader.uniforms["vOffset"].value.x -= (delta * this.noiseOffsetSpeed) * this.windDirection.x;
        this.noiseShader.uniforms["vOffset"].value.y += (delta * this.noiseOffsetSpeed) * this.windDirection.z;
      }
      this.renderer.render(this.noiseScene, this.noiseCameraOrtho, this.noiseMap, true);
      if ((_ref = this.controls) != null ? _ref.enabled : void 0) {
        if ((_ref1 = this.controls) != null) {
          _ref1.update();
        }
      }
      this.renderer.render(this.scene, this.camera);
      THREE.AnimationHandler.update(delta);
    };

    App.prototype.onWindowResize = function() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      $("#loading").css({
        'position': 'absolute',
        'width': 400,
        "height": 100,
        'left': window.innerWidth / 2 - 200,
        'top': window.innerHeight / 2 - 50
      });
    };

    return App;

  })();

  $(function() {
    return $(document).ready(function() {
      if (!Detector.webgl || !Detector.workers) {
        return Detector.addGetWebGLMessage();
      } else {
        return new App;
      }
    });
  });

}).call(this);
